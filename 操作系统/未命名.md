##### epoll的好处是可以在单进程里处理多个io，这里的单进程指的是用户进程还是内核进程呢

在这里，“单进程”指的是用户进程。使用epoll可以让单个用户进程同时管理多个I/O事件，而不用创建多个线程或进程来同时处理多个I/O事件，充分利用了计算机的性能。同时，由于Linux内核提供了epoll_wait系统调用，可以异步监听多个文件描述符上的I/O事件，因此epoll也具有高效的事件通知机制。

##### 如果某个请求处理时间过长，会不会导致其他处理阻塞呢

如果你在一个单进程中使用阻塞I/O，如果某个请求的处理时间过长，则会使得整个进程阻塞，从而无法处理其他请求。这会导致性能下降，并且可能会影响用户体验。

而使用非阻塞I/O和异步I/O的方式，可以避免阻塞问题。在这种情况下，每个请求都被视为一个事件，当事件就绪时会通知用户进程，进程可以在某个特定的时间点或其他条件下处理事件。如果某个事件处理时间过长，其他事件不会阻塞，因为事件处理的执行数量是在用户进程控制之下的。这种方式可以提高处理请求的效率和并发处理的能力。使用epoll等I/O多路复用机制可以更好地支持非阻塞I/O和异步I/O。

##### 普通的多线程客户端和上述epoll客户端有什么差别呢

普通的多线程客户端和使用epoll的客户端的主要区别在于它们处理I/O的方式。普通的多线程客户端通常使用阻塞I/O，即每一个客户端连接都会创建一个线程，该线程会一直阻塞，直到接收到该客户端的数据。这种方式会导致操作系统创建大量的线程，会占用很多的内存和CPU资源，从而无法支持更大规模的并发客户端。

而使用epoll机制的客户端可以采用非阻塞I/O和异步I/O的方式来处理事件，将事件（如客户端连接请求，客户端数据到达等）组织成事件列表（event list）后，通过epoll_wait等待这些事件的发生。这种方式可以支持更多的并发连接、更高效的I/O操作，减少了线程和进程的切换，避免了阻塞I/O带来的资源浪费，从而提高了客户端的性能和可扩展性。

##### 如果采用非阻塞IO了，那是不是意味着epoll不是在单进程或线程里处理请求了？

使用非阻塞I/O的方式和使用epoll机制并不矛盾，它们可以同时使用。事实上，常见的做法是使用epoll机制来实现非阻塞I/O或异步I/O。

在使用epoll的方式中，对事件（如客户端连接请求、客户端数据到达等）进行ET模式的处理，可以让读取事件的回调函数以非阻塞的方式进行数据的读取。如果读取缓冲区没有数据，epoll的等待函数不会阻塞进程，进程可以继续执行其他任务。等有数据到来时，epoll会立即通知进程回调函数来读取数据。这样，一个进程就可以同时处理多个I/O事件，避免了阻塞I/O带来的资源浪费，提高了应用程序的效率。

因此，在使用epoll的方式中，仍然可以在单进程中进行I/O请求的管理与处理，而且使用非阻塞I/O的方式可以让I/O的处理变得更加高效、响应速度更快、支持更多的并发连接。

##### 举一个简单的例子呢，对比“同时使用非阻塞IO和epoll”和“只使用非阻塞IO而不使用epoll”

假设我们要开发一个简单的Web服务器，支持多个客户端同时连接并请求资源。如果我们使用非阻塞I/O并同时使用epoll，我们的处理流程大致如下：

1. 创建服务器端socket并绑定端口号。
2. 创建epoll并将服务器端socket加入到epoll的监听事件中。
3. 在epoll_wait函数中等待事件的发生，如有新客户端连接请求到达，则将此连接的socket加入到epoll的监听事件中。
4. 当有socket上有可读事件的时候，epoll_wait函数返回，调用读取事件的回调函数读入数据。
5. 处理完请求后，将客户端socket从epoll上删除，并关闭连接。

如果我们只使用非阻塞I/O而不使用epoll，则我们的处理流程大致如下：

1. 创建服务器端socket并绑定端口号。
2. 设置服务器端socket为非阻塞模式。
3. 等待客户端连接请求到来，并处理连接请求，得到客户端socket。
4. 将客户端socket设置为非阻塞模式。
5. 在读取客户端数据时，在读取缓冲区中循环尝试读取，如果没有数据则不阻塞，而是等待下一轮循环（轮询）。
6. 处理完客户端请求后，将客户端socket关闭。

通过对比，我们可以看出：

如果只采用非阻塞I/O而不使用epoll，会构造一个无限循环来轮询每一个socket，这种轮询的方式会占用CPU资源，并且无法高效地处理大量的连接，同时也无法支持高并发的连接请求。

而使用同时使用非阻塞I/O和epoll，可以让一个进程同时最大化处理多个连接，避免了资源浪费，提高了响应速度和并发能力。

因此，使用epoll和非阻塞I/O的方式可以更高效地处理多个请求，同时支持更高的并发连接和请求。

##### 总结

总结一下，这里的单线程/进程指的并不是处理请求的线程，而是轮询线程，使用epoll仍需要配合多工作线程，也就是非阻塞IO模式。区别只是在于，如果使用普通的轮询线程，那么在用户态轮询所有已连接的socket（有数据的和没有数据的），将有数据的连接分配工作线程处理掉，select/poll模式是将连接交给操作系统，期间有用户态->内核态和内核态->用户态的连接数据拷贝，而且是每次轮询都需要拷贝，使用固定长度的BitsMap或链表等线性结构，由操作系统轮询，epoll比select/poll更优的是使用红黑树维护连接，只返回有事件发生的连接的个数，避免大量的数据拷贝。