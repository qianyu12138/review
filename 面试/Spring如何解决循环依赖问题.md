##### Spring如何解决循环依赖问题

首先循环依赖是一种正常的情况，只是因为Spring容器对**构造函数**配置Bean进行实例化有一个前提，**被注入的对象必须处于已准备好的状态**，而循环依赖时被注入的对象中还有未注入的属性，**所以解决方法就是将其中一个Bean采用setter方式注入**

##### redis缓存同步问题

因为写和读是并发的，没法保证顺序，如果删了缓存，还没有来得及写库，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。如果先写了库，再删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。 如果是redis集群，或者主从模式，写主读从，由于redis复制存在一定的时间延迟，也有可能导致数据不一致。

解决方法是双删加超时，在写数据库前后都操作缓存，最差情况在超时时间内数据不一致。

##### 缓存击穿

缓存击穿表示恶意用户模拟请求很多缓存中不存在的数据，由于缓存中都没有，导致这些请求短时间内直接落在了数据库上，导致数据库异常。（最好读写分离）

解决方法：

使用互斥锁排队，根据key获取value的值为空时，将数据库操作加锁。

接口限流

使用布隆过滤器（可以快速返回key值是否存在）

##### 缓存穿透

缓存在同一时间内大量失效，造成短时数据库压力过大。

加锁排队

缓存超时时间+随机时间，避免同时过期

建立备份缓存，不同的超时时间

##### 缓存雪崩

redis服务器挂掉造成数据库压力过大

##### 代理模式与装饰器模式的区别

代理模式和装饰器模式都要求实现同一接口，都很容易的在原始对象前后加自定义方法。

装饰器模式关注于在对象上动态的添加方法，然而代理模式关注于控制对对象的访问。当使用代理模式的时候通常在代理类中创建一个对象实例，当使用装饰器模式时，通常的做法是将原始对象作为一个参数传递给代理对象。

使用代理模式，代理对象与原始对象的关系在编译时就已经确定了；而装饰者能够在运行时递归地被构造。