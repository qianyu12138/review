### IO模型

#### 阻塞IO模型

在读写数据的过程中发生的阻塞现象，当用户发出IO请求时，内核查看数据是否就绪，如果没有就绪就会让用户线程等待，并且不能执行其他任务，直到资源被释放，拿到执行权限并执行完IO操作，才继续向下执行后续任务。

#### 非阻塞IO模型

当用户发出IO请求时，会立刻得到一个结果，如果结果是error，用户可以再次请求，或转而执行其他任务。在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就是说非阻塞IO不会交出CPU，而是一直占用CPU。导致的一个问题就是如果不能拿到执行权限，CPU占用率会非常高。

#### 多路复用IO模型

Java的NIO就是多路复用IO。

用户线程操作IO时，分为两个部分，1.获取socket状态 2.执行任务，其中获取socket状态统一由一个线程轮询，当IO资源可用时再分配线程执行IO。在轮询线程获取状态时，不会占用IO资源。在Java NIO中，通过selector.select()去查询每个channel是否有到达事件。多路复用IO比较适合连接数比较多的情况。

多路复用IO比非阻塞IO效率高是因为在非阻塞IO中，不断询问socket状态是由用户线程执行的，而多路复用是在内核中进行的。

#### 异步IO模型

当用户发起IO请求时，会立即得到一个响应状态，并且可以开始执行其他任务。不会产生任何阻塞。当IO操作完成时，用户线程会得到一个通知，告诉她IO已经执行完成。

也就说在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完 成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的读写。 

异步IO需要操作系统支持，在Java7中，提供 Asynchronous IO 。

### Java NIO

主要核心组件：Channel，Buffer，Selector

传统IO基于字节流，NIO基于缓冲区

Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何 地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在 缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所 有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。 

#### NIO的非阻塞

个人理解：NIO的非阻塞体现在其selector上，比如

阻塞IO：第一个请求进入并执行IO任务，未执行完第二个请求只能等待

NIO：第一个请求进入并执行任务，第二个请求进入在另一个工作线程（channel）执行任务，作为接受请求的线程，需要处理的只是分配任务。

#### Channel

与Stream类似，只是Stream是单向的（InputStream，OutputStream），Channel是双向的（读写）

实现：
FileChannel（文件IO）

DatagramChannel（UDP）

SocketChannel（TCP Server）

SocketChannel（TCP Client）

#### Buffer

实际上是一个连续数组

子类：ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、 ShortBuffer 

#### Selector

Selector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事 件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可 以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用 函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护 多个线程，并且避免了多线程之间的上下文切换导致的开销。 



