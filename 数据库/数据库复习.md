# **数据库复习**

### 主键、外键、超键、候选键

超键：在关系中能唯一标识元组的列属性，可由多个属性组合成超键

候选键：没有冗余元素的超键。

主键：标识了一个表中的元组的属性或属性的组合，唯一，not null

外键：在一个表中表示另一个表数据的主键

### 为什么用自增列作主键

在InnoDB引擎中，创建表之后会自动创建一个索引，情况如下：

1. 定义了主键，选择该主键作为索引

2. 没有定义主键，选择一个not null列作为索引

3. 无not null，自定义一个6字节rowid作为隐含的索引

所有数据在一棵由索引构建的B+Tree上，即同一节点的数据要按照主键顺序存放，达到加载因子自动开一个新页。当新数据增加时，

自增主键直接加在后续位置，写满自动开辟一页。

非自增主键需要插入在中间的某个位置，而该位置所处的页可能已经不在缓存中，要到磁盘中寻找，增加开销，造成大量碎片，得到了不紧凑的索引结构。（通过OPTIMIZE TABLE重建表优化）

### 存储过程

一个预编译的SQL语句，供程序多次调用，允许模块化设计。

调用方式：命令对象、外部程序

### 视图的优缺点

用户通过简单的查询完成复杂查询的结果

### 范式

1NF 属性不可分

2NF 非主键属性完全依赖于主键属性

3NF 非主键属性无传递依赖

### drop、truncate、delete

drop：直接删除表 DLL

Truncate：删除表中所有数据，id重置，不可撤销，不会激活触发器，执行速度快，表结构、约束、索引不变 DLL

Delete：删除表中、视图中数据，删除每一条数据都成为一个事务，可撤销 DML

空间上，truncate恢复初始大小

### 关系型数据库与非关系型数据库

##### 非关系型优势：

性能：基于键值对，不需要经过SQL层解析，性能高。（MangoDB可复杂查询，乐观锁保持原子操作）

可扩展：没有耦合性

海量数据的高效率读写

##### 关系型优势：

易于维护：完整性（实体完整性，参照完整性，用户定义完整性）

复杂查询

事务支持

### 内连接、外连接、笛卡儿积

Inner join：两表都保留，无对应属性赋值null

Left (outer) join: 左表保留，右表对应插入，无对应赋值null

Cross join：将一个数据源中的每个行与另一个数据源的每个行都一一匹配

### char与varchar

char长度固定，char[10]，速度快

存储方式：char 每个英文字符占1字节，汉字2字节；varchar 都是2字节

### SQL语言分类

数据查询语言DQL：SELECT FROM WHERE

数据操纵语言DML：INSERT UPDATE DELETE

数据定义语言DDL：CREATE TABLE/VIEW/INDEX...

数据控制语言DCL：GRANT（授权）ROLLBACK COMMIT

### 索引 

数据库索引是独立于数据的用于排序的数据结构，通常使用BTree或B+TREE实现，索引以某种方式指向数据，可实现高级查找算法。

协助快速查询、更新表中数据

代价：空间，插入修改的额外时间

 

优点：

1. 通过创建唯一性索引，保证表中数据的唯一性

2. 加快数据的检索速度（主要原因）

3. 加速表与表之间的连接

4. 减少查询中分组和排序的时间

5. 在查询的过程中，使用优化隐藏器，提高系统性能

缺点：

1. 增加索引维护的时间开销，这种开销随数据量的增加而增加

2. 占用物理空间

### 哪些适合建立索引，哪些不适合

应该：

1. 经常搜索的列，加快搜索速度

2. 主键，强制该列的唯一性和组织表中数据的排列结构

3. 经常用在连接的列，主要是外键，加快连接速度

4. 范围查询的列

5. 排序的列

6. Where子句上（or左右都要建立，否则不生效）

不应该：

1. 在查询中很少使用的列

2. text image bit数据量大、取值少的列

3. 修改性能远远打与检索性能（增加索引提高检索性能，降低修改性能）

### MySQL中B+Tree索引和Hash索引

由于本身数据结构的原因

Hash检索效率非常高，索引的检索可以一次定位

B+Tree所有检索都需要从根节点到枝节点，最后到页节点的多次IO访问

为什么不都用Hash索引：

1. Hash索引仅仅能满足= IN等查询，不能依靠Hash值范围查询

2. 无法用来排序操作

3. 对于组合索引，不能对部分索引查询（组合索引是各个索引共同计算出来的Hash值）

4. 不能避免表扫描，因为满足某个Hash键值的记录不止一个（哈希碰撞）

5. 当数据量过大，性能并不比B+Tree高

MySQL中，只有HEAP/MEMORTY引擎支持Hash索引

InnoDB中默认使用B+Tree索引，开启自适应哈希索引，如果判定Hash索引可以提高查询效率，会在“自适应哈希索引缓冲区”建立哈希索引

### B+Tree相对于B Tree

1. B+的磁盘读写代价更低

B+的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对于B Tree更小。如果把所有同一内部节点的关键字放在同一盘块中，盘块中含有待查询的关键字数量也越多。无需跳越多个盘块，IO读写次数也就降低了

2. B+Tree的查询效率更加稳定

相比于B Tree,B+Tree在所有查询中都是从根节点到叶子节点，查询路径长度都相同。

### 聚集索引和非聚集索引

聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率高，只要找到第一个索引值记录，紧随其后的就是其他的记录，缺点就是修改慢。（拼音）

非聚集索引指定表中记录的逻辑顺序，叶子层包含一个指向表中记录在数据页中的指针方式。（部首）

### 索引失效条件

or （需要给每个条件都建立索引）

like ，以%开发

内部函数

对索引列进行计算

Is null

### 事务

事务是对数据库中一系列操作进行统一回滚或提交的操作，主要用来保证数据的完整性和一致性。

原子性：指事务中包含的一系列操作要么全部成功，要么全部失败回滚，不可分割。

一致性：事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没增加。

隔离性：多个用户同时访问数据库时，系统为每个用户开启一个事务，不能被其他事务的操作干扰。同一时间只允许一个事务请求同一数据。

持久性：事务一旦被提交，对数据库的数据改变时永久性的。

### 事务的隔离级别

事务完全隔离会导致性能下降。

##### 问题：

脏读：事务A读取事务B更新的数据后，B回滚。

不可重复读：事务A多次读取同一数据，期间事务B对该数据进行更新，导致A读的数据不一致。(**脏读与不可重复读的区别在于B事务是否提交**)

幻读：事务A通过某条件读取数据，期间事务B修改该条件，导致事务A读取的记录不一致。

##### 事务的隔离级别：

读未提交：另一事务修改了数据但未提交，本事务会读取到修改的数据（脏读）

不可重复读（读已提交）

可重复读：多次读取数据，都是该事务开始状态的数据（幻读）

串行化：最高隔离级别，不会产生任何异常

默认可重复读，隔离级别需要数据库引擎的支持

### 事务的传播行为

1.PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。

2.PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。

3.PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。

4.PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。

5.PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

6.PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。

7.PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。

 

### InnoDB、MyISAM、MEMORY存储引擎

1. InnoDB支持事务，MyISAM不支持

2. MyISAM适合查询和插入为主

3. InnoDB支持外键，MyISAM不支持

4. InnoDB适合频繁修改以及安全性较高的应用

5. 从MySQL5.5.5以后，InnoDB为默认引擎

6. InnoDB不支持FULLTEXT类型的索引

7. InnoDB不保存行数，每次count()都需要扫描整个表；MyISAM保存行数，但又where时仍需扫描表。

8. InnoDB支持行锁（只在WHERE主键的情况下有效）

MEMORY是MySQL的一种特殊的存储引擎，在磁盘中为每个表创建文件保存表的结构，而数据全部存到内存中，默认使用Hash索引

### 数据库优化方法

1. explain优化sql和索引

2. 开启慢查询日志

### 数据库锁

MySQL锁级别：

表级锁：开销小，加锁快，不会出现死锁，发生锁冲突概率高，并发度低

行级锁：开销大，加锁慢，会出现死锁，发生锁冲突概率低，并发度高

页面锁：介于表锁和行锁之间，会出现死锁。

 

死锁解决办法：kill进程，设置超时时间，指定锁获取顺序

### 乐观锁和悲观锁

悲观锁：先获取锁，在进行业务操作

以select for update实现，先获取被select的行的行锁进行操作，在事务结束后释放

Oracle提供nowait选项，拿不到锁立刻报错

乐观锁：先进行操作，再获取一下锁

完全逻辑实现，不需要数据库提供支持，一般做法是增加一个版本号，如果失败就回滚。回滚的开销较大，适用于取锁失败概率小的场景以提高系统并发性能。

### 并发解决方案：Master-slave

分库、分表、分布式、增加二级缓存

 

### 并发解决方案：Master-slave

主从复制的几种方式：

同步复制：master变化，等待所有slaves完成后再返回。（不可取）

异步复制：master完成变化后立即返回，不等待slaves。

半同步复制：等待任意一个slave完成后返回slave。

MySQL的读写分离：

Insert/delete/update用master，select用slaves。Master挂了，找一个slaves代替master。

###  SQL语句执行流程

FROM	ON	JOIN	WHERE	GROUP BY	SELECT	HAVING	ORDER BY	LIMIT